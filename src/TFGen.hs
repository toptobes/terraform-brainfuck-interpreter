module TFGen (genTfFiles) where

import Data.Text qualified as T
import FileActions
import Options
import Interpreter

genTfFiles :: Options -> FileActionF ()
genTfFiles opts = do
  when opts.force $ do
    deleteDir opts.outDir

  let opts' = case opts.code of
       Just code -> case eval code (fromMaybe "" opts.input) of
        Left err  -> error $ show err
        Right res -> opts { maxInterpSteps = res.interpSteps, maxLUTGenSteps = res.lutGenSteps, tapeLength = Just res.maxTapeLen }
       Nothing -> opts

  mkRoot opts'

generationNotice :: Text
generationNotice = ""
  <> "########################################################################\n"
  <> "# This file was auto-generated by the Terrafuck CLI                    #\n"
  <> "# https://github.com/toptobes/terrform-brainfuck-interpreter           #\n"
  <> "#                                                                      #\n"
  <> "# (please send help I'm locked in his basement being forced to re-type #\n"
  <> "# all of this by hand each time the CLI is called or he won't feed me) #\n"
  <> "########################################################################\n"

mkRoot :: Options -> FileActionF ()
mkRoot opts = do
  entryTemplate <- mkRootFileTemplate opts
  let entryFile = FileDesc "main.tf" (generationNotice <> "\n" <> entryTemplate)
  
  dirs <- sequence
    [ mkTemplateModule "interpreter" opts.maxInterpSteps
    , mkTemplateModule "bracket_lut" opts.maxLUTGenSteps
    ]

  createDir $ DirDesc opts.outDir [entryFile] dirs

mkRootFileTemplate :: Options -> FileActionF Text
mkRootFileTemplate opts = useTemplateFile "root/main.tf" 
  [ ("maybe_default_tape", maybeDefaultTape)
  , ("maybe_default_code", maybeDefaultCode)
  , ("default_input", defaultInput)
  ]
  where 
    maybeDefaultTape = maybe "" (\l -> "\n  default     = " <> show (replicate @Int l 0)) opts.tapeLength
    maybeDefaultCode = maybe "" (\c -> "\n  default     = " <> show c) opts.code
    defaultInput = show $ fromMaybe "" opts.input

mkTemplateModule :: FilePath -> Int -> FileActionF DirDesc
mkTemplateModule name size = do
  contentStart <- useTemplateFile (name <> "/start.tf") []

  contentIntermediate <- forM [1..size] $ \i -> do
    useTemplateFile (name <> "/step.tf") [("i", show i), ("pi", show $ i - 1)]

  contentEnd <- useTemplateFile (name <> "/end.tf") [("pi", show size)]

  let content = T.intercalate "\n" $ concat [[generationNotice, contentStart], contentIntermediate, [contentEnd]]
      mainFile = FileDesc "main.tf" content

  pure $ DirDesc ("modules/" <> name) [mainFile] []
